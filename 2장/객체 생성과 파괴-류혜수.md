# 아이템 1: 생성자 대신 정적 팩터리 메서드를 고려하라

클래스의 인스턴스를 얻는 가장 전통적인 방법은 `public` 생성자를 호출하는 것이다. 그러나 많은 경우 **정적 팩터리 메서드**가 더 나은 대안이 될 수 있다.

## 장점

1. **이름을 가질 수 있다**
    - 메서드 이름을 통해 반환될 객체의 특성을 드러낼 수 있다.
    - 매개변수만 다른 여러 생성자가 존재할 때 혼동을 피할 수 있다.
2. **호출될 때마다 반드시 새로운 객체를 생성하지 않아도 된다**
    - 불변 클래스의 경우 미리 만들어둔 인스턴스를 재사용하거나 캐싱할 수 있다.
    - 객체의 생애주기를 통제할 수 있다.
        - 예: 싱글턴, 인스턴스 불가
3. **반환 타입의 하위 타입 객체를 반환할 수 있다**
    - 구체적인 구현 클래스를 감추고 인터페이스나 추상 클래스 타입으로 반환할 수 있다.
    - API를 단순화하고 은닉성을 강화할 수 있다.
4. **입력 매개변수에 따라 다른 클래스 객체를 반환할 수 있다**
    - 반환 타입의 하위 타입이라면 어떤 클래스든 상황에 맞게 선택할 수 있다.
    - 클라이언트는 반환되는 실제 클래스의 존재조차 알 필요가 없다.
5. **작성 시점에 반환할 클래스가 존재하지 않아도 된다**
    - 나중에 구현체를 추가하거나 교체할 수 있어 확장성이 높다.
    - 이를 기반으로 **서비스 제공자 프레임워크(Service Provider Framework)** 를 만들 수 있다.
        - 구성 요소
            1. 서비스 인터페이스
            2. 제공자 등록 API
            3. 서비스 접근 API
            4. 서비스 제공자 인터페이스(SPI, 팩터리 역할)
        - 관련 기법
            - 브리지 패턴
            - 의존성 주입(Dependency Injection)

## 단점

1. **하위 클래스를 만들 수 없다**
    - 상속을 위해서는 `public` 또는 `protected` 생성자가 필요하기 때문이다.
2. **API에서 눈에 잘 띄지 않는다**
    - 생성자와 달리 문서나 관례 없이는 쉽게 찾기 어렵다.
    - 따라서 널리 쓰이는 명명 규칙을 따르는 것이 중요하다.
        - 예: `of`, `from`, `valueOf`, `getInstance`, `newInstance`, `getType`, `newType`

---

# 아이템 2: 생성자에 매개변수가 많으면 빌더를 고려하라

생성자나 정적 팩터리 메서드는 매개변수가 적을 때는 적합하다. 그러나 **선택적 매개변수가 많아지면 대응하기 어렵다.**

이를 해결하기 위한 대안은 다음과 같다.

## 1. 점층적 생성자 패턴

- 매개변수가 늘어날 때마다 생성자를 추가로 정의하는 방식.
- 매개변수 개수가 많아지면 **호출 코드 가독성이 떨어지고, 사용이 불편**하다.

## 2. 자바빈즈 패턴

- 매개변수가 없는 생성자를 호출한 후, **setter 메서드**로 값을 설정.
- 단점
    - 객체 하나를 만들기 위해 여러 메서드를 호출해야 한다.
    - 객체가 완성되기 전까지 **일관성이 무너질 수 있다.**
    - 불변으로 만들 수 없으므로 별도의 `freeze` 메서드 같은 추가 작업이 필요하다.
    - 이러한 방식은 런타임 오류에 취약하다.

## 3. 빌더 패턴 (권장)

```jsx
public class NutritionFacts {
    private final int servingSize;
    private final int servings; 
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // 필수 매개변수
        private final int servingSize;
        private final int servings;

        // 선택 매개변수 - 기본값으로 초기화
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) { calories = val; return this; }
        public Builder fat(int val) { fat = val; return this; }
        public Builder sodium(int val) { sodium = val; return this; }
        public Builder carbohydrate(int val) { carbohydrate = val; return this; }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}

```

- 필수 매개변수만 생성자나 정적 팩터리로 전달하고, 선택 매개변수는 빌더 객체의 메서드로 설정한다.
- 마지막에 `build()` 메서드를 호출해 객체를 얻는다.

### 장점

- 쓰기도 읽기도 쉽다.
- 선택적 매개변수를 자유롭게 조합할 수 있다.
- 불변 객체를 쉽게 만들 수 있다.
- 계층적으로 설계된 클래스에 적합하다.

### 계층적 설계에서의 예시: Pizza

```jsx
abstract class Pizza {
    public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }
    final Set<Topping> toppings;

    abstract static class Builder<**T extends Builder<T>**> {
        EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);
        public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return self();
        }
        abstract Pizza build();
        **protected abstract T self(); // 하위 빌더 타입 반환!**
    }

    Pizza(Builder<?> builder) {
        toppings = builder.toppings.clone();
    }
}

class NyPizza extends Pizza {
    public enum Size { SMALL, MEDIUM, LARGE }
    private final Size size;

    static class Builder extends Pizza.Builder<Builder> {
        private final Size size;
        Builder(Size size) {
            this.size = Objects.requireNonNull(size);
        }
        @Override public NyPizza build() {
            return new NyPizza(this);
        }
        @Override protected Builder self() { return this; }
    }

    private NyPizza(Builder builder) {
        super(builder);
        size = builder.size;
    }
}

class Calzone extends Pizza {
    private final boolean sauceInside;

    static class Builder extends Pizza.Builder<Builder> {
        private boolean sauceInside = false;

        public Builder sauceInside() {
            sauceInside = true;
            return this;
        }

        @Override public Calzone build() {
            return new Calzone(this);
        }
        @Override protected Builder self() { return this; }
    }

    private Calzone(Builder builder) {
        super(builder);
        sauceInside = builder.sauceInside;
    }
}

```

- 여기서 계층적으로 설계된 클래스라 함은 상속 관계를 가진 클래스를 의미하는 듯
- `Pizza.Builder` 클래스는 재귀적 타입 한정을 사용한다.
- 이를 통해 하위 클래스에서 빌더 메서드 체인을 사용할 때 형변환이 필요 없다.
- 하위 클래스는 빌더를 오버라이딩하여 자신에게 맞는 빌더를 반환하면 된다.

---

# 아이템 3: private 생성자나 열거 타입으로 싱글턴임을 보장하라

**싱글턴(Singleton)** 은 인스턴스를 오직 하나만 생성할 수 있는 클래스다. 다만 일반 클래스로 싱글턴을 구현하면 **테스트가 어려워지는 단점**이 있다.

## 싱글턴을 만드는 방식

### 1. `public static final` 필드 방식

- 생성자를 `private`으로 두고, 유일한 인스턴스를 `public static final` 필드에 담아 제공한다.
- 장점
    - 싱글턴임이 API에 명백히 드러난다.
    - 구현이 간결하다.

### 2. 정적 팩터리 메서드 방식

- `private` 생성자를 두고, 인스턴스는 `public static` 메서드로 제공한다.
- 장점
    - API를 바꾸지 않고도 싱글턴을 다중 인스턴스로 변경할 수 있다.
    - 제네릭 싱글턴 팩터리를 만들 수 있다.
    - 정적 팩터리 메서드를 **공급자(Supplier)** 로 사용할 수 있다.

> **직렬화 시 문제와 해결**
> 
- 위 두 방식(`public static final`, 정적 팩터리)을 사용할 경우, 직렬화 시 별도의 처리가 필요하다.
- 해결 방법
    - 모든 인스턴스 필드를 `transient` 로 선언한다.
    - `readResolve` 메서드를 제공해 역직렬화 시 기존 인스턴스를 반환하도록 한다.
    
    ```jsx
    public Object readResolve(){
    	return INSTACNE;
    }
    ```
    
- 그렇지 않으면 역직렬화 과정에서 새로운 인스턴스가 생성된다.

## 3. 원소가 하나인 열거 타입 방식

- 가장 단순하고 안전한 방식.
- 장점
    - 추가적인 노력 없이 직렬화가 가능하다.
        - 직렬화 방식이 특수 처리되어 있어서 JVM이 미리 로딩해준 enum 상수의 참조를 반환함
    - 리플렉션 공격에도 제2의 인스턴스가 생기지 않는다.
        - 원래는 접근할 수 없는 생성자나 필드에 강제로 접근해 객체를 만듦
    - 구현이 명확하고 코드가 간결하다.
- 단점
    - 만들려고 하는 싱글턴이 Enum 이외의 클래스를 상속해야 한다면 사용 불가
- 따라서 **싱글턴을 구현하는 가장 좋은 방법**으로 권장된다.

---

# 아이템 4: 인스턴스화를 막으려거든 private 생성자를 사용하라

가끔은 **정적 메서드와 정적 필드만 담은 클래스**가 필요하다.

- 이 경우 생성자를 명시하지 않으면 **컴파일러가 기본 생성자**를 만들어 인스턴스를 생성할 수 있게 된다.
- 추상 클래스로 선언해도 소용없다. 하위 클래스를 정의해 인스턴스를 만들 수 있기 때문이다.
- 따라서 **인스턴스화를 막으려면 `private` 생성자를 명시적으로 선언해야 한다.**

---

# 아이템 5: 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

많은 클래스는 하나 이상의 자원에 의존한다.
잘못된 방식은 이를 **정적 유틸리티 클래스**로 구현하거나, **싱글턴으로 직접 참조**하는 것이다.

## 문제점

- 특정 자원에 고정되어 다른 자원으로 교체하기 어렵다.
- 테스트하기 불편하다.
- 멀티스레드 환경에서 문제를 일으킬 수 있다.

## 해결책: 의존 객체 주입 (Dependency Injection)

- 필요한 자원을 클라이언트가 직접 넘긴다.
- 이 방식은 자원이 몇 개든, 의존 관계가 복잡하든 잘 동작한다.

```java
class SpellChecker {
    private final Dictionary dictionary;

    public SpellChecker(Dictionary dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }
}
```

## 변형: 팩터리 메서드를 이용한 의존성 주입

- `Supplier<T>` 인터페이스를 사용해 자원의 팩터리 를 주입할 수 있다.
    - 여기서 `Supplier` 를 통해 객체 직접 생성 대신 주입받아 원하는 시점에 원하는 구현체를 생성할 수 있음
- 이를 통해 지정한 타입의 하위 타입이라면 무엇이든 생성할 수 있다.

```java
class Mosaic {
    Mosaic(Supplier<? extends Tile> tileFactory) { ... }
}

```

---

# 아이템 6: 불필요한 객체 생성을 피하라

같은 기능의 객체를 반복해서 새로 생성하기보다는 **재사용하는 편이 더 낫다.**
그 근거는 다음과 같다.

- **예시 1: `String`**
    - `new String()` 은 실행될 때마다 인스턴스를 새로 만든다. 따라서 하나의 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다.
- **예시 2: 정적 팩터리 메서드**
    - `Boolean.valueOf(String)` 은 항상 새로운 객체를 만들지 않고, 미리 만들어둔 인스턴스를 반환한다.
- **예시 3: 생성 비용이 비싼 객체**
    - 정규 표현식(`Pattern`)
    - `String.matches()` 는 내부적으로 매번 정규식을 새로 컴파일한다.
    - 대신 `Pattern` 인스턴스를 재사용하면 성능이 크게 향상된다.

## 객체를 재사용하는 경우

1. **지연 초기화**
    - 필요할 때 객체를 생성해 캐싱하는 방식.
    - 다만 코드가 복잡해져서 일반적으로는 권장하지 않는다.
2. **불변 객체**
    - 안전하게 공유·재사용 가능하다.
    - 예: `String`, `Integer.valueOf(int)`
3. **가변 객체**
    - 직관적으로는 위험해 보이지만, 특정 상황에서는 재사용 가능하다.
    - 예: 어댑터(Adapter) 객체는 내부적으로 같은 뒷단 객체를 감싸고만 있으면 된다.
4. **오토박싱 대신 기본 타입**
    - `Long sum = 0L;` 처럼 래퍼 타입을 반복적으로 생성하면 불필요한 객체가 많이 만들어진다.
    - 기본 타입(`long`)을 사용하는 것이 더 효율적이다.

## 객체 재사용이 항상 최선은 아닌 이유

- 현대 JVM은 **GC와 메모리 관리 성능이 매우 뛰어나다.**
- 따라서 가벼운 객체까지 무리하게 객체 풀을 만드는 것은 오히려 성능 저하로 이어질 수 있다.
- 즉, **재사용의 이점보다 비용이 더 커질 수 있다.**

---

# 아이템 7: 다 쓴 객체 참조를 해제하라

자바는 GC가 있어 C/C++처럼 명시적으로 메모리를 해제할 필요는 없다.

그러나 **자체적으로 메모리를 관리하는 클래스**를 작성한다면 **다 쓴 객체 참조를 해제**하지 않으면 메모리 누수가 발생한다.

## 주요 사례

1. **스택(stack)**
    - `pop` 호출 시, 다 쓴 객체 참조를 `null` 처리해야 한다.
    - 이렇게 하면 GC가 더 이상 필요 없는 객체를 회수할 수 있다.
    - 근데 `null` 처리보다 불필요한 참조를 범위 밖으로 밀어내는 게 더 낫다.
2. **캐시**
    - 캐시에 저장된 객체가 불필요하게 오래 살아남아 메모리 누수를 일으킬 수 있다.
    - 해결 방법
        1. 캐시 외부에서 키를 참조하는 동안만 유효해야 한다면 **`WeakHashMap`** 사용.
        2. 일반적으로는 시간을 두고 엔트리의 가치를 떨어뜨린다.
            - 일정 시간이 지나면 엔트리 제거.
                - 백그라운드 스레드로 청소
                - 새로운 엔트리 추가 시, 부수 작업으로 청소 (`LinkedHashMap`)
        3. 더 정교한 방법이 필요하다면 `java.lang.ref` 패키지를 활용한다.
3. **리스너와 콜백(listener & callback)**
    - 클라이언트가 등록만 하고 해제하지 않으면 메모리 누수가 발생한다.
    - 해결 방법: **약한 참조(weak reference)** 로 저장해 GC가 회수할 수 있도록 한다

.

---

# 아이템 8: finalizer와 cleaner 사용을 피해라

## 문제점

- `finalizer`와 `cleaner`는 **예측할 수 없고, 위험하며, 성능 저하를 유발한다.**
- 주요 근거
    1. 즉시 수행된다는 보장이 없다. 실행 시점은 GC에 달려 있다.
    2. 아예 수행되지 않을 수도 있다.
        - DB와 같은 자원 해제에는 절대 사용하면 안 된다.
    3. `finalizer`는 예외를 무시하고 종료할 수 있다. (`cleaner`는 예외 전달 가능)
    4. 심각한 성능 문제를 일으킬 수 있다.
    5. **finalizer 공격**이라는 보안 취약점에 노출된다.

## 권장 대안

- 자원을 직접 해제해야 한다면 `AutoCloseable`을 구현하고, 클라이언트가 `close()` 메서드를 호출하도록 한다.
- `close()`에서는 자원이 해제되었음을 기록하고, 중복 호출 시 `IllegalStateException`을 던지도록 한다.
- `try-with-resources`를 활용하면 `close()` 호출을 자동화할 수 있다.

## 사용 가능한 경우

1. **안전망**으로 사용
    - 심각한 문제가 발생했을 때 완전히 방치하는 것보다 나을 수 있다.
2. **네이티브 피어(native peer)** 와 연결된 객체
    - GC가 관리하지 못하는 네이티브 자원을 해제할 때 보조적으로 사용할 수 있다.
    - 단, 성능 저하를 감수해야 한다.
3. **내부 구현에서 한정적으로 사용**
    - 예: `Room` 클래스 내부에서 cleaner를 안전망으로 활용.

---

# 아이템 9: try-finally보다 try-with-resources를 사용하라

자바에는 `close()` 메서드를 호출해 직접 닫아야 하는 자원이 많다.

전통적으로는 `try-finally`를 사용했지만, 이는 여러 문제를 야기한다.

## 1. try-finally 방식

```java
InputStream in = new FileInputStream(src);
try {
    // 작업 수행
} finally {
    in.close();
}
```

- 자원이 두 개 이상일 경우 코드가 복잡해진다.
- `try` 블록과 `finally` 블록 양쪽에서 예외가 발생하면, 후자의 예외가 전자의 예외를 덮어버려 **원인 파악이 어렵다.**

## 2. try-with-resources 방식

- 자원이 `AutoCloseable` 인터페이스를 구현해야 한다.
- 구문이 간결하며, 예외 처리도 안전하다.

```java
try (InputStream in = new FileInputStream(src);
     OutputStream out = new FileOutputStream(dst)) {
    // 작업 수행
}

```

- `try` 블록과 `close()` 호출 양쪽에서 예외가 발생하면, **첫 번째 예외가 보존**되고 두 번째 예외는 **suppressed exception**으로 기록된다.
- `catch` 블록과 함께 사용할 수 있어 다중 예외 처리도 용이하다.
