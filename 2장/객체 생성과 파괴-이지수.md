# 1. 생성자 대신 정적 팩터리 메서드
## 장점
- 이름을 가질 수 있다
    - 생성자 : BigInteger(int, int, Random)
    - 정적 팩터리 : BigInteger.probablePrime
- 호출될 때마다 인스턴스를 새로 생성하지 않아도 됨
    - → 불변객체는 캐싱 등 재활용 가능
- 하위 타입 객체 반환 가능
    - → 인터페이스 만으로 객체를 다룸
- 입력 매개 변수에 따라 **매번** 다른 클래스의 객체 반환
- 작성 시점에서 반환 객체의 클래스가 존재하지 않아도 됨
    - ex) JDBC
## 단점
- 상속하려면 생성자가 필요함
- 프로그래머가 찾기 어려움


# 2. 생성자에 매개변수가 많으면 빌더 고려
- 점층적 생성자 패턴
    - 갯수 주의, 순서 주의
- 자바빈즈 패턴(빈 생성자 + 세터)
    - 객체 하나를 위해 여러 메서드 호출해야 함
    - 매개변수 일관성 X
## 단점
- 객체에 앞서 빌더부터 생성 필요
- 매개변수 적을 땐 굳이..


# 3. private 생성자 or 열거타입으로 싱글턴 보증
- private 생성자 : static-final / 정적 팩터리 getInstance
    - → 직렬화 X
- 열거타입 (원소 1개)


# 4. private 생성자로 인스턴스화 막기
- 생성자 X → 컴파일러가 자동 생성해버림
- 추상클래스 → 상속해서 쓰라는건가?
- private 생성자 사용하면 ok


# 5. 자원 직접 명시 x → 의존 객체 주입 사용
- 상위…? di??


# 6. 불필요한 객체 생성 피하기
- 특히 불변객체는 재사용 가능
- 생성자 대신 정적 팩터리 메서드(아이템1) 이용하기
- 정규 표현식의 사례
- 어댑터 사례(Map 인터페이스의 KeySet)
- 오토박싱(Long, long)


# 7. 다 쓴 객체 참조 해제
- 스택: 메모리를 직접 관리하기 때문에 가비지 컬렉터가 회수X
- 캐시 → weakHashMap


# 8. finalizer, cleaner 사용 피하기
- 실행 시점, 실행 여부 보장X
    - 없으면 그냥 gc가 처리?
- 경고출력x
- 보안 노출
- —> autoClosable 구현
- close 호출


# 9. try-finally보다는 try-with-resources 사용